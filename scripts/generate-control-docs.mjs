#!/usr/bin/env node
/**
 * @fileoverview Generate control catalog documentation from YAML catalog.
 * @license Apache-2.0
 */
import { createHash } from 'node:crypto';
import fs from 'node:fs';
import path from 'node:path';
import process from 'node:process';
import { fileURLToPath } from 'node:url';
import { parse } from 'yaml';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const repoRoot = path.resolve(__dirname, '..');

const catalogPath = path.join(repoRoot, 'brainwav', 'governance', '90-infra', 'control-registry.core.yaml');
const outputDir = path.join(repoRoot, 'brainwav', 'governance', 'generated');
const outputFile = path.join(outputDir, 'control-catalog.md');
const manifestFile = path.join(outputDir, 'control-catalog.manifest.json');

/**
 * Compute SHA-256 hash for content.
 * @param {string} content - Content to hash.
 * @returns {string} Hex digest.
 */
function sha256(content) {
	return createHash('sha256').update(content).digest('hex');
}

/**
 * Ensure a directory exists.
 * @param {string} dir - Directory path.
 * @returns {void} No return value.
 */
function ensureDir(dir) {
	fs.mkdirSync(dir, { recursive: true });
}

/**
 * Load and validate the control catalog YAML.
 * @returns {{raw: string, data: Record<string, unknown>}} Catalog content.
 */
function loadCatalog() {
	if (!fs.existsSync(catalogPath)) {
		throw new Error(`Control catalog not found: ${catalogPath}`);
	}
	const raw = fs.readFileSync(catalogPath, 'utf8');
	const data = parse(raw);
	if (!data || !Array.isArray(data.controls)) {
		throw new Error('Control catalog must contain a controls array.');
	}
	return { raw, data };
}

/**
 * Render the control table as markdown.
 * @param {Array<Record<string, unknown>>} controls - Control entries.
 * @returns {string} Markdown table.
 */
function renderTable(controls) {
	const header = '| ID | Title | Enforcement | Scope | Gates | Owner | Evidence |';
	const divider = '| --- | --- | --- | --- | --- | --- | --- |';
	const rows = controls.map((control) => {
		const scope = Array.isArray(control.scope) ? control.scope.join(', ') : '';
		const gates = Array.isArray(control.gates) ? control.gates.join(', ') : '';
		const evidence = Array.isArray(control.evidence_required)
			? control.evidence_required.join('<br>')
			: '';
		return `| ${control.control_id} | ${control.title} | ${control.enforcement} | ${scope} | ${gates} | ${control.owner} | ${evidence} |`;
	});
	return [header, divider, ...rows].join('\n');
}

/**
 * Summarize control counts by status and enforcement.
 * @param {Array<Record<string, unknown>>} controls - Control entries.
 * @returns {{total: number, active: number, deprecated: number, hard: number, soft: number}} Summary.
 */
function summarize(controls) {
	const total = controls.length;
	const active = controls.filter((c) => c.status === 'active').length;
	const deprecated = controls.filter((c) => c.status === 'deprecated').length;
	const hard = controls.filter((c) => c.enforcement === 'hard').length;
	const soft = controls.filter((c) => c.enforcement === 'soft').length;
	return { total, active, deprecated, hard, soft };
}

/**
 * Build the generated markdown content.
 * @param {Record<string, unknown>} data - Parsed catalog data.
 * @returns {string} Generated markdown.
 */
function buildMarkdown(data) {
	const controls = data.controls;
	const summary = summarize(controls);
	const generatedAt = new Date().toISOString();
	return `# Control Catalog (Generated)\n\n` +
		`> Source: ${path.relative(repoRoot, catalogPath)}\n` +
		`> Generated: ${generatedAt}\n\n` +
		`Do not edit this file directly. Update the catalog and re-run the generator.\n\n` +
		`## Summary\n\n` +
		`- Total controls: ${summary.total}\n` +
		`- Active: ${summary.active}\n` +
		`- Deprecated: ${summary.deprecated}\n` +
		`- Enforcement: hard=${summary.hard}, soft=${summary.soft}\n\n` +
		`## Controls\n\n` +
		`${renderTable(controls)}\n`;
}

/**
 * Write the generation manifest for traceability.
 * @param {string} markdown - Generated markdown.
 * @param {string} catalogRaw - Raw catalog YAML.
 * @returns {void} No return value.
 */
function writeManifest(markdown, catalogRaw) {
	const manifest = {
		generatedAt: new Date().toISOString(),
		sourceCatalog: path.relative(repoRoot, catalogPath),
		output: path.relative(repoRoot, outputFile),
		checksums: {
			catalog_sha256: sha256(catalogRaw),
			output_sha256: sha256(markdown)
		}
	};
	fs.writeFileSync(manifestFile, `${JSON.stringify(manifest, null, 2)}\n`);
}

/**
 * Generate the control catalog documentation.
 * @returns {void} No return value.
 */
function main() {
	try {
		const { raw, data } = loadCatalog();
		ensureDir(outputDir);
		const markdown = buildMarkdown(data);
		fs.writeFileSync(outputFile, markdown);
		writeManifest(markdown, raw);
		console.log(`[brAInwav] Generated ${path.relative(repoRoot, outputFile)}`);
		console.log(`[brAInwav] Wrote ${path.relative(repoRoot, manifestFile)}`);
	} catch (error) {
		console.error(`[brAInwav] control catalog generation failed: ${error.message}`);
		process.exitCode = 1;
	}
}

if (import.meta.url === `file://${process.argv[1]}`) {
	main();
}

export default main;
